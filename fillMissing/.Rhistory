for (i in 1:length(indList)){
#curData = RDONLY[RDONLY$sic ==indList[i],]
curData = RDANDNUM[RDANDNUM$sic == indList[i],]
dataList[[length(dataList)+1]]= curData
nameVector[[length(nameVector)+1]]= indList[i]
#}
}
#clean inputs for each industry
oneVarList = list()
twoVarList = list()
numCosList = list()
startYearList = list()
#for (i in 1:length(nameVector)){
#  curData = dataList[[i]]
#  curDataOneVar = ddply(curData, ~datayear,
#    function(df) {
#      res = data.frame(rbind(df$xrdAdj)) #take R&D spending as a percentage of sales
#      names(res) = sprintf("%s",df$gvkey)
#      res
#    }
#  )
#  startYearList[[i]]= min(curDataOneVar$datayear)
#  numCos = ncol(curDataOneVar)-1
#  model.data = curDataOneVar[-c(1)] #delete time entry
#  model.data = as.matrix(model.data)
#  model.data = t(model.data)
#  oneVarList[[i]]= model.data
#  numCosList[[i]] = numCos
#}
for (i in 1:length(nameVector)){
curData = dataList[[i]]
curDataOneVar = ddply(curData, ~datayear,
function(df) {
res = data.frame(rbind(df$xrdAdj)) #take R&D spending as a percentage of sales
names(res) = sprintf("%s",df$gvkey)
res
}
)
curDataTwoVar = ddply(curData, ~datayear,
function(df) {
res = data.frame(rbind(df$npatappAdj))
names(res) = sprintf("%s",df$gvkey)
res
}
)
numCos = ncol(curDataOneVar)-1
model.data = curDataOneVar[-c(1)] #delete time entry
model.data2 =curDataTwoVar[-c(1)]
model.data = as.matrix(model.data)
model.data2 = as.matrix(model.data2)
model.data = t(model.data)
model.data2 = t(model.data2)
model.data2 = rbind(model.data, model.data2)
oneVarList[[i]]= model.data
twoVarList[[i]]= model.data2
numCosList[[i]] = numCos
startYearList[[i]]= min(curDataOneVar$datayear)
oneVarList[[i]]= model.data
numCosList[[i]] = numCos
twoVarList[[i]]= model.data2
}
BAll = "identity"
QAll= "diagonal and unequal" #note this could be changed if it causes problems since the unequal portion is irrelevant (it is a 1 by 1 matrix)
AAll = "equal" #company inputs are allowed to have trends
UAll = "equal"
RAll = "diagonal and equal"
ZAll = matrix(1,1,1)
pointList = data.frame(matrix(ncol = 9, nrow = 0))
colnames(pointList) = c("industryName","companyName", "year", "raw", "arEst", "ssEst", "meanEst", "maEst", "isEst")
output.data = data.frame(matrix(ncol = 4, nrow = 0))
colnames(output.data)= c("industryName", "companyName", "coeff1",  "intercept")
output.data.ss = data.frame(matrix(ncol = 8, nrow = 0))
colnames(output.data.ss)= c("industryName", "companyName", "logLik", "numParams", "AICc", "States", "SEs", "converge")
control.list = list(safe = TRUE, trace =1, allow.degen= TRUE, maxit = 1000,conv.test.slope.tol=0.1)
#run models with 10 points and project up to 15===============================================================
for (i in 1:length(twoVarList)){ #industry loop
curData = twoVarList[[i]]
industryName = nameVector[i]
companyNameVector = rownames(curData)
for (j in 1:(nrow(curData)/2)){#for each company, run model
#set up inputdata
companyName = companyNameVector[j]
coData = curData[j,]
coNum = curData[j+nrow(curData)/2,]
if (length(coData[is.na(coData)])<length(coData)){ #we have some non-NA entries
nonNA1 = which(!is.na(coData))
startIndex1 = min(nonNA1)
endIndex1 = max(nonNA1)
startYear = startYearList[[i]][1]-startIndex1 + 1
coNum = coNum[startIndex1:endIndex1]
coData = na.trim(coData)
numYears = length(coData)
if (numYears > 14 & length(coData)== length(na.exclude(coData))){ #we must have 15 non-NA points
coDataUse = coData[1:10] #use first 10 points for model
curPointList = data.frame(matrix(ncol =9, nrow = numYears))
colnames(curPointList) = c("industryName","companyName", "year", "raw", "arEst", "ssEst", "meanEst", "maEst", "isEst")
curPointList$raw= coData
curPointList$industryName = industryName
curPointList$companyName = companyName
curPointList$year = c(startYear:(startYear+numYears-1))
#run model AR model
curMod = ar.ols(coDataUse, AIC = FALSE, order.max = 1, intercept = TRUE, demean = FALSE, na.action = na.exclude)
if (is.na(curMod$ar[1])){
coeffs = c(NA, NA, NA)
}
else{
coeffs = curMod$ar[[1]]
int = curMod$x.intercept
coeffs = c(coeffs, int)
}
#do prediction here
preds = predict(curMod, newdata = coData[1:10],n.ahead = (numYears-10))
curPointList$arEst[11:numYears]= preds$pred
#run state space model
model.list = list(B=BAll, U=UAll, Q=QAll, A=AAll, R=RAll,  Z=ZAll)
model.current = MARSS(coDataUse, model = model.list, miss.value =NA, control = control.list)
#store output
if (is.null(model.current$num.params)){
print("failone")
numParams = NA
AICc = NA
curStates = NA
curSE = NA
curConv = NA
stateVect = rep(NA, numYears)
seVect = rep(NA, numYears)
} else{
numParams = model.current$num.params
AICc = model.current$AICc
stateVect = model.current$states[1,]
seVect = model.current$states.se[1,]
curStates = toString(model.current$states)
curSE = toString(model.current$states.se)
curConv = model.current$converge
#predict and store
sim.data=MARSSsimulate(model.current, nsim=1, tSteps=(numYears-10))
curPointList$ssEst[11:numYears] = sim.data$sim.data
}
if (is.null(model.current$logLik)){
logLik = NA
}else{
logLik = model.current$logLik
}
#run mean model and predict
curMod = mean(coDataUse)
preds = rep(curMod, numYears-11)
curPointList$meanEst[11:numYears] = curMod
#run MA(3) model and predict
# curMod = arma(coDataUse,order = c(0,2), include.intercept = TRUE)
if(length(coDataUse)==length(coDataUse[coDataUse==0])){
coeffes = c(NA,NA,NA)
}
else{
curModMA= arima(coDataUse, order = c(0,0,2))
coeffs = curModMA$coef
}
#do prediction here
predsMA = predict(curModMA,n.ahead = (numYears-10))
curPointList$maEst[11:numYears]= predsMA$pred
#do idiosyncratic error
stdev= sd(coDataUse)
predsIS = rnorm(n=numYears-10, m=curMod, sd=stdev)
curPointList$isEst[11:numYears]= predsIS
#write outputs
#ar
cur.outdata =data.frame(industry= industryName,company= companyName, coeff1 = coeffs[1], int = coeffs[2], stringsAsFactors = FALSE)
colnames(cur.outdata)= colnames(output.data)
output.data= rbind(output.data, cur.outdata)
#ss
cur.outdata =data.frame(industry= industryName,company= companyName, logLik = logLik, numParams = numParams, AICc = AICc, states = curStates, ses = curSE, converge =curConv, stringsAsFactors = FALSE)
colnames(cur.outdata)= colnames(output.data.ss)
output.data.ss= rbind(output.data.ss, cur.outdata)
#points
colnames(curPointList)= colnames(pointList)
pointList = rbind(pointList, curPointList)
}
}
}
}
write.csv(pointList, "pointList2.csv")
length(levels(as.factor(pointList$companyName)))
successAR = pointList[!is.na(pointList$arEst),]
length(levels(as.factor(successAR$companyName)))
successSS = pointList[!is.na(pointList$ssEst),]
length(levels(as.factor(successSS$companyName)))
#select only companies where state space model runs
successCos = levels(as.factor(successSS$companyName))
pointListUse = pointList[pointList$companyName %in% successCos,]
pointListUse = pointListUse[!(is.na(pointListUse$arEst)),]
pointListHold = pointList
#setup
pointList = data.frame(matrix(ncol = 8, nrow = 0))
colnames(pointList) = c("industryName","companyName", "raw", "meanEst", "year", "numPatents", "maEst", "isEst")
output.data.mean = data.frame(matrix(ncol = 3, nrow = 0))
colnames(output.data.mean)= c("industryName", "companyName", "mean")
#model
for (i in 1:length(twoVarList)){ #industry loop
curData = twoVarList[[i]]
industryName = nameVector[i]
companyNameVector = rownames(curData)
for (j in 1:(nrow(curData)/2)){#for each company, run model
#set up inputdata
companyName = companyNameVector[j]
coData = curData[j,]
coNum = curData[j+nrow(curData)/2,]
if (length(coData[is.na(coData)])<length(coData)){ #we have some non-NA entries
nonNA1 = which(!is.na(coData))
startIndex1 = min(nonNA1)
endIndex1 = max(nonNA1)
startYear = startYearList[[i]][1]-startIndex1 + 1
coData = na.trim(coData)
coNum = coNum[startIndex1:endIndex1]
numYears = length(coData)
if (numYears > 14 & length(coData)== length(na.exclude(coData))){ #we must have 15 non-NA points
coDataUse = coData[1:10] #use first 10 points for model
curPointList = data.frame(matrix(ncol = 8, nrow = numYears))
colnames(curPointList) = c("industryName","companyName", "raw", "meanEst", "year", "numPatents", "maEst", "isEst")
curPointList$raw= coData
curPointList$industryName = industryName
curPointList$companyName = companyName
curPointList$year = c(startYear:(startYear+numYears-1))
curPointList$numPatents = coNum
#run mean model and predict
curMod = mean(coDataUse)
preds = rep(curMod, numYears-11)
curPointList$meanEst[11:numYears] = curMod
#run MA(3) model and predict
# curMod = arma(coDataUse,order = c(0,2), include.intercept = TRUE)
if(length(coDataUse)==length(coDataUse[coDataUse==0])){
coeffes = c(NA,NA,NA)
}
else{
curModMA= arima(coDataUse, order = c(0,0,2))
coeffs = curModMA$coef
}
#do prediction here
predsMA = predict(curModMA,n.ahead = (numYears-10))
curPointList$maEst[11:numYears]= predsMA$pred
#do idiosyncratic error
stdev= sd(coDataUse)
predsIS = rnorm(n=numYears-10, m=curMod, sd=stdev)
curPointList$isEst[11:numYears]= predsIS
#write outputs
#mean model
cur.outdata =data.frame(industry= industryName,company= companyName, mean = curMod, stringsAsFactors = FALSE)
colnames(cur.outdata)= colnames(output.data.mean)
output.data.mean= rbind(output.data.mean, cur.outdata)
#points
colnames(curPointList)= colnames(pointList)
pointList = rbind(pointList, curPointList)
}
}
}
}
write.csv(pointList, "pointList3.csv")
pointList = read.csv("inputs/compiledPointList.csv")
pointList = read.csv("inputs/compiledPointList.csv")
#overview of numbers of companies
length(levels(as.factor(pointList$companyName)))
successAR = pointList[!is.na(pointList$arEst),]
length(levels(as.factor(successAR$companyName)))
successSS = pointList[!is.na(pointList$ssEst),]
length(levels(as.factor(successSS$companyName)))
colnames(pointList)
successAR = pointList[!is.na(pointList$meanEst),]
length(levels(as.factor(successAR$companyName)))
successAR = pointList[!is.na(pointList$maEst),]
length(levels(as.factor(successAR$companyName)))
successAR = pointList[!is.na(pointList$isEst),]
length(levels(as.factor(successAR$companyName)))
successAR = pointList[!is.na(pointList$arEst),]
MseAR = sum((successAR$arEst-successAR$raw)^2)
successMean = pointList[!is.na(pointList$meanEst),]
MseMean = sum((successMean$meanEst-successMean$raw)^2)
MseSS = sum((successSS$ssEst-successSS$raw)^2)
successAR$seAR = (successAR$arEst-successAR$raw)^2
successSS$seSS = (successSS$ssEst-successSS$raw)^2
successMean$seMean = (successMean$meanEst-successMean$raw)^2
successAR$seAR = (successAR$arEst-successAR$raw)^2
errors_dat = data.frame(companyName = aggregate(successAR$seAR, list(gp=successAR$companyName), sum)$gp,
mseAR = aggregate(successAR$seAR, list(gp=successAR$companyName), mean)$x,
errors_dat = data.frame(companyName = aggregate(successAR$seAR, list(gp=successAR$companyName), sum)$gp,
mseAR = aggregate(successAR$seAR, list(gp=successAR$companyName), mean)$x)
mseAR
errors_dat$mseAR
mean(errors_dat$mseAR)
sd(errors_dat$mseAR)
successSS$seSS = (successSS$ssEst-successSS$raw)^2
errors_SS = data.frame(companyName = aggregate(successSS$seAR, list(gp=successSS$companyName), sum)$gp,
mseSS = aggregate(successSS$seAR, list(gp=successSS$companyName), mean)$x)
errors_SS = data.frame(companyName = aggregate(successSS$seSS, list(gp=successSS$companyName), sum)$gp,
mseSS = aggregate(successSS$seSS, list(gp=successSS$companyName), mean)$x)
means(errors_SS$mseSS)
sd(errors_SS$mseSS)
mean(errors_SS$mseSS)
sd(errors_SS$mseSS)
successMean$seMean = (successMean$MeanEst-successMean$raw)^2
successMean = pointList[!is.na(pointList$meanEst),]
dim(successMean)
successMean$seMean = (successMean$meanEst-successMean$raw)^2
successMean$seMean = (successMean$meanEst-successMean$raw)^2
errors_Mean = data.frame(companyName = aggregate(successMean$seMean, list(gp=successMean$companyName), sum)$gp,
mseSS = aggregate(successMean$seMean, list(gp=successMean$companyName), mean)$x)
mean(errors_Mean$mseMean)
sd(errors_Mean$mseMean)
errors_Mean = data.frame(companyName = aggregate(successMean$seMean, list(gp=successMean$companyName), sum)$gp,
mseMean = aggregate(successMean$seMean, list(gp=successMean$companyName), mean)$x)
mean(errors_Mean$mseMean)
sd(errors_Mean$mseMean)
dim(errors_Mean)
dim(successMean)
dim(pointList)
dim(successSS)
dim(errors_SS)
mean(errors_AR$mseAR)
sd(errors_AR$mseAR)
successAR$seAR = (successAR$arEst-successAR$raw)^2
errors_AR = data.frame(companyName = aggregate(successAR$seAR, list(gp=successAR$companyName), sum)$gp,
mseAR = aggregate(successAR$seAR, list(gp=successAR$companyName), mean)$x)
mean(errors_AR$mseAR)
sd(errors_AR$mseAR)
dim(errors_AR)
dim(successAR)
colnames(pointList)
successMA$seMA = (successMA$maEst-successMA$raw)^2
successMean = pointList[!is.na(pointList$meanEst),]
successMA = pointList[!is.na(pointList$maEst),]
successMA$seMA = (successMA$maEst-successMA$raw)^2
errors_MA = data.frame(companyName = aggregate(successMA$seMA, list(gp=successMA$companyName), sum)$gp,
mseMA = aggregate(successMA$seMA, list(gp=successMA$companyName), mean)$x)
mean(errors_MA$mseMA)
sd(errors_MA$mseMA)
dim(errors_MA)
successIS$seIS = (successIS$isEst-successIS$raw)^2
successIS = pointList[!is.na(pointList$isEst),]
successIS$seIS = (successIS$isEst-successIS$raw)^2
errors_IS = data.frame(companyName = aggregate(successIS$seIS, list(gp=successIS$companyName), sum)$gp,
mseIS = aggregate(successIS$seIS, list(gp=successIS$companyName), mean)$x)
mean(errors_IS$mseIS)
sd(errors_IS$mseIS)
errors_AR = errors_AR[!(errors_AR$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_AR$mseAR)
sd(errors_AR$mseAR)
dim(errors)AR
dim(errors_AR)
errors_SS = errors_SS[!(errors_S$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_SS$mseSS)
errors_SS = errors_SS[!(errors_SS$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_SS$mseSS)
sd(errors_SS$mseSS)
dim(errors_SS)
errors_Mean = errors_Mean[!(errors_Mean$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_Mean$mseMean)
sd(errors_Mean$mseMean)
dim(mseMean)
dim(errors_Mean)
errors_MA = errors_MA[!(errors_MA$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_MA$mseMA)
sd(errors_MA$mseMA)
dim(errors_MA)
errors_IS = errors_IS[!(errors_IS$companyName %in% c(1585,24922,11768,24473,25302,27747,29245,20245,27727,23605,12227,12274,13794)),]
mean(errors_IS$mseIS)
sd(errors_IS$mseIS)
ss.mod = lm(numPats~ssEst, data = successSS)
colnames(successSS)
ss.mod = lm(numPatents~ssEst, data = successSS)
summary(ss.mod)
ar.mod = lm(numPats~arEst, data = successAR)
ar.mod = lm(numPatents~arEst, data = successAR)
summary(ar.mod)
mean.mod = lm(numPatents~meanEst, data = successMean)
summary(mean.mod)
ma.mod = lm(numPatents~maEst, data = successMA)
summary(ma.mod)
is.mod = lm(numPatents~isEst, data = successIS)
summary(is.mod)
cor(successAR$arEst, successAR$numPatents)
cor(successSS$ssEst, successSS$numPatents)
cor(successMean$meanEst, successMean$numPatents)
cor(successMA$maEst, successMA$numPatents)
cor(successIS$isEst, successIS$numPatents)
#model setup================================================================================
BAll = "identity"
QAll= "diagonal and unequal" #note this could be changed if it causes problems since the unequal portion is irrelevant (it is a 1 by 1 matrix)
AAll = "equal" #company inputs are allowed to have trends
UAll = "equal"
RAll = "diagonal and equal"
ZAll = matrix(1,1,1)
pointList = data.frame(matrix(ncol = 11, nrow = 0))
colnames(pointList) = c("industryName","companyName", "year", "raw", "numPats","arEst", "ssEst", "meanEst", "maEst", "isEst", "armaEst")
output.data = data.frame(matrix(ncol = 4, nrow = 0))
colnames(output.data)= c("industryName", "companyName", "coeff1",  "intercept")
output.data.ss = data.frame(matrix(ncol = 8, nrow = 0))
colnames(output.data.ss)= c("industryName", "companyName", "logLik", "numParams", "AICc", "States", "SEs", "converge")
control.list = list(safe = TRUE, trace =1, allow.degen= TRUE, maxit = 1000,conv.test.slope.tol=0.1)
#run models with 10 points and project up to 15===============================================================
for (i in 1:length(twoVarList)){ #industry loop
curData = twoVarList[[i]]
industryName = nameVector[i]
companyNameVector = rownames(curData)
for (j in 1:(nrow(curData)/2)){#for each company, run model
#set up inputdata
companyName = companyNameVector[j]
coData = curData[j,]
coNum = curData[j+nrow(curData)/2,]
if (length(coData[is.na(coData)])<length(coData)){ #we have some non-NA entries
nonNA1 = which(!is.na(coData))
startIndex1 = min(nonNA1)
endIndex1 = max(nonNA1)
startYear = startYearList[[i]][1]-startIndex1 + 1
coNum = coNum[startIndex1:endIndex1]
coData = na.trim(coData)
numYears = length(coData)
if (numYears > 14 & length(coData)== length(na.exclude(coData))){ #we must have 15 non-NA points
coDataUse = coData[1:10] #use first 10 points for model
curPointList = data.frame(matrix(ncol =11, nrow = numYears))
colnames(curPointList) = c("industryName","companyName", "year", "raw","numPats", "arEst", "ssEst", "meanEst", "maEst", "isEst", "armaEst")
curPointList$raw= coData
curPointList$industryName = industryName
curPointList$companyName = companyName
curPointList$year = c(startYear:(startYear+numYears-1))
curPointList$numPats = coNum
#run model AR model
curMod = ar.ols(coDataUse, AIC = FALSE, order.max = 1, intercept = TRUE, demean = FALSE, na.action = na.exclude)
if (is.na(curMod$ar[1])){
coeffs = c(NA, NA, NA)
}
else{
coeffs = curMod$ar[[1]]
int = curMod$x.intercept
coeffs = c(coeffs, int)
}
#do prediction here
preds = predict(curMod, newdata = coData[1:10],n.ahead = (numYears-10))
curPointList$arEst[11:numYears]= preds$pred
#run state space model
model.list = list(B=BAll, U=UAll, Q=QAll, A=AAll, R=RAll,  Z=ZAll)
#model.current = MARSS(coDataUse, model = model.list, miss.value =NA, control = control.list)
#store output
#if (is.null(model.current$num.params)){
print("failone")
numParams = NA
AICc = NA
curStates = NA
curSE = NA
curConv = NA
stateVect = rep(NA, numYears)
seVect = rep(NA, numYears)
#} else{
#numParams = model.current$num.params
#AICc = model.current$AICc
#stateVect = model.current$states[1,]
#seVect = model.current$states.se[1,]
#curStates = toString(model.current$states)
#curSE = toString(model.current$states.se)
#curConv = model.current$converge
#predict and store
#sim.data=MARSSsimulate(model.current, nsim=1, tSteps=(numYears-10))
#curPointList$ssEst[11:numYears] = sim.data$sim.data
#}
#if (is.null(model.current$logLik)){
logLik = NA
#}else{
#  logLik = model.current$logLik
#}
#run mean model and predict
curMod = mean(coDataUse)
preds = rep(curMod, numYears-11)
curPointList$meanEst[11:numYears] = curMod
#run MA(2) model and predict
# curMod = arma(coDataUse,order = c(0,2), include.intercept = TRUE)
if(length(coDataUse)==length(coDataUse[coDataUse==0])){
coeffes = c(NA,NA,NA)
}
else{
curModMA= arima(coDataUse, order = c(0,0,2))
coeffs = curModMA$coef
}
#do prediction here
predsMA = predict(curModMA,n.ahead = (numYears-10))
curPointList$maEst[11:numYears]= predsMA$pred
#do idiosyncratic error
stdev= sd(coDataUse)
predsIS = rnorm(n=numYears-10, m=curMod, sd=stdev)
curPointList$isEst[11:numYears]= predsIS
#run arma model
if(length(coDataUse)==length(coDataUse[coDataUse==0])){
coeffs = c(NA,NA,NA,NA)
}
else{
curModARMA= arima(coDataUse, order = c(1,0,2))
coeffs = curModARMA$coef
}
#do prediction here
predsARMA = predict(curModARMA,n.ahead = (numYears-10))
curPointList$armaEst[11:numYears]= predsARMA$pred
#write outputs
#ar
cur.outdata =data.frame(industry= industryName,company= companyName, coeff1 = coeffs[1], int = coeffs[2], stringsAsFactors = FALSE)
colnames(cur.outdata)= colnames(output.data)
output.data= rbind(output.data, cur.outdata)
#ss
cur.outdata =data.frame(industry= industryName,company= companyName, logLik = logLik, numParams = numParams, AICc = AICc, states = curStates, ses = curSE, converge =curConv, stringsAsFactors = FALSE)
colnames(cur.outdata)= colnames(output.data.ss)
output.data.ss= rbind(output.data.ss, cur.outdata)
#points
colnames(curPointList)= colnames(pointList)
pointList = rbind(pointList, curPointList)
}
}
}
}
